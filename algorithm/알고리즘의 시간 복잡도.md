# 알고리즘의 시간 복잡도

> 좋은 알고리즘 == 효율성이 좋은 알고리즘 인가?
> 
> => 성능이 좋은 알고리즘?
> 
> == input을 넣은 후 output이 나오는 시간이 짧은 알고리즘

- 짧은 시간, 적은 메모리

- 각각 시간복잡도, 공간복잡도

- 시간>공간

- 알고리즘의 소요 시간 측정하기 - 1
  
  - 컴퓨터에 따라 측정 시간이 다르다. -> 객관적 기준 필요

- 알고리즘의 소요 시간 측정하기 - 2
  
  - 알고리즘 내부에서 기본연산이 몇 번 일어나는지 
  
  - 기본연산 : 단위 시간 1이 소요되는 연산
  
  - 예) 할당, 산술, 비교, 반환 ....

기본연산의 총 횟수 == 알고리즘의 소요시간

시간 복잡도

단순하게 알고리즘의 수행 시간을 의미

**시간 복잡도가 높다 -> 느린 알고리즘**

**시간 복잡도가 낮다 -> 빠른 알고리즘**

# Big -O표기법

- 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것

- 최고차항만 남기고 계수와 상수 제거

- 매 입력에 따라 정확한 수식을 구하는 것은 불필요하다.

- 정확한 수치보다는 증가율에 초점을 둔다.

- O(1): 단순 산술 계산(덧셈, 뺄셈, 곱셉, 나눗셈)

- O(logN): 크기 N인 리스트를 반절씩 순회/탐색

- O(N): 크기 N인 리스트를 순회

- O(NlogN): 크기 N인 리스트를 반절씩 탐색 * 순회

- O(N^2): 크기 M, N인 2중 리스트를 순회

- O(N^3): 3중 리스트를 순회

- O(2^N): 크기 N 집합의 부분 집합

- O(N!): 크기 N 리스트의 순열

- O(1): 단순계산 -> a + b, 100 * 200

- O(logN): 이진탐색(Binary Search), 분할정복(Divide & Conquer)

- O(N): 리스트 순회, 1중 for 문

- O(NlogN): 높은 성능의 정렬(Merge/Quick/Heap Sort)

- O(N^2): 2중 리스트 순회, 2중 for 문

- O(N^3): 3중 리스트 순회, 3중 for 문

- O(2^N): 크기가 N인 집합의 부분 집합

- O(N!): 크기가 N인 순열

**내장 함수, 메서드의 시간 복잡도도 확인할 필요가 있다.**

for문안에 O(n)의 내장 함수를 사용했다면 사실상 이중 for문을 사용한 것과 다를 것이 없다.

# 배열

여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조

- 인덱스를 통해 데이터에 빠르게 접근

- 배열의 길이는 변경 불가능 -> 길이를 변경하고 싶다면 새로 생성

- 데이터 타입은 고정

# 연결 리스트

데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

- 맨 처음 노드부터 순차적으로 탐색

- 연결리스트의 길이 자유롭게 변경 가능 -> 삽입, 삭제가 편리

- 다양한 데이터 타입 저장

- 데이터가 메모리에 연속적으로 저장되지 않음

## 파이썬 리스트의 메서드

1. .append()

2. .pop()

3. .count()

4. .index()

5. .sort()

6. .reverse()

## 자주 쓰이는 리스트 관련 내장함수

1. len()

2. sum()

3. max()

4. min()

5. sorted()

6. reversed()

# 리스트 컴프리헨션

코드 한줄만으로 새로운 리스트를 만드는 방법이다.

```python
numbers = []
for i in range(5):
    numbers.append(i)

print(numbers)
```

=>

```python
numbers = [i for i in range(5)]

print(numbers)
```
